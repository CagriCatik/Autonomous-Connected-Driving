"use strict";(self.webpackChunkacd=self.webpackChunkacd||[]).push([[1004],{8869:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"task/sensor_data_processing/Deep-OGM","title":"Deep Learning-based Point Cloud Occupancy Grid Mapping","description":"ROS1","source":"@site/docs/task/02_sensor_data_processing/02_Deep-OGM.md","sourceDirName":"task/02_sensor_data_processing","slug":"/task/sensor_data_processing/Deep-OGM","permalink":"/Autonomous-Connected-Driving/docs/task/sensor_data_processing/Deep-OGM","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/task/02_sensor_data_processing/02_Deep-OGM.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"taskSidebar","previous":{"title":"Camera-based Semantic Grid Mapping","permalink":"/Autonomous-Connected-Driving/docs/task/sensor_data_processing/Camera-based-Semantic-Grid-Mapping"},"next":{"title":"Geometric Point Cloud Occupancy Grid Mapping","permalink":"/Autonomous-Connected-Driving/docs/task/sensor_data_processing/Geometric-OGM"}}');var c=o(4848),i=o(8453);const r={},t="Deep Learning-based Point Cloud Occupancy Grid Mapping",a={},d=[{value:"Task 5: Convert Tensor to Grid Map",id:"task-5-convert-tensor-to-grid-map",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"deep-learning-based-point-cloud-occupancy-grid-mapping",children:"Deep Learning-based Point Cloud Occupancy Grid Mapping"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://img.shields.io/badge/ROS1-blue",alt:"ROS1"})}),"\n",(0,c.jsxs)(n.p,{children:["In the previous task, you have completed and used a geometric approach to create occupancy grid maps from lidar point clouds. Now, we will use the ",(0,c.jsx)(n.strong,{children:"deep learning-based inverse sensor model"})," instead."]}),"\n",(0,c.jsx)(n.h2,{id:"task-5-convert-tensor-to-grid-map",children:"Task 5: Convert Tensor to Grid Map"}),"\n",(0,c.jsxs)(n.p,{children:["A TensorFlow model that was trained on synthetic data is already included in the repository at ",(0,c.jsx)(n.code,{children:"pointcloud_ogm/models/"}),". The ROS nodelet ",(0,c.jsx)(n.code,{children:"pointcloud_ogm/DeepISM"})," receives point clouds and uses the TensorFlow model to predict occupancy grid maps. Start the nodelet and Rviz:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"roslaunch pointcloud_ogm DeepISM.launch\n"})}),"\n",(0,c.jsxs)(n.p,{children:['Rviz will show the lidar point cloud. If you enable the checkbox next to "Grid Map (DeepISM)" you will also see an occupancy grid map, but ',(0,c.jsx)(n.strong,{children:"there is something wrong"}),"."]}),"\n",(0,c.jsx)("img",{src:"../images/rviz_deepISM.PNG",alt:"Description of image"}),"\n",(0,c.jsxs)(n.p,{children:["Have a look at the code in ",(0,c.jsx)(n.code,{children:"workshops/section_2/pointcloud_ogm/src/DeepISM.cpp"}),". The node performs the following steps:"]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"On start, size and resolution of the predicted grid map is obtained from the loaded TensorFlow model."}),"\n",(0,c.jsxs)(n.li,{children:["When a point cloud is received, the ",(0,c.jsx)(n.code,{children:"messageCallback()"})," method is executed.","\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"The point cloud is converted into input tensors for the neural network using the PointPillars approach."}),"\n",(0,c.jsx)(n.li,{children:"The TensorFlow model is used to predict occupancy evidences from the input tensors."}),"\n",(0,c.jsxs)(n.li,{children:["The method ",(0,c.jsx)(n.code,{children:"tensor_to_grid_map()"})," converts the predicted tensor into an occupancy grid map."]}),"\n",(0,c.jsx)(n.li,{children:"The occupancy grid map is published as ROS message."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:'void DeepISM::tensor_to_grid_map(const float* prediction, grid_map::GridMap& grid_map)\n{\n  // TASK 5 START: Find the bug in the following code.\n  const auto& rows = grid_map.getSize()(0);\n  const auto& cols = grid_map.getSize()(1);\n  for (int row = 0; row < rows; row++)\n  {\n    for (int col = 0; col < cols; col++)\n    {\n      const auto& evidence_free = prediction[0 + row*cols*2 + col*2 + 0];\n      const auto& evidence_occupied = prediction[0 + row*cols*2 + col*2 + 1];\n      auto& m_occupied = grid_map.at("m_occupied", grid_map::Index(row, col));\n      auto& m_free = grid_map.at("m_free", grid_map::Index(row, col));\n      auto& occupancy_color = grid_map.at("occupancy_color", grid_map::Index(row, col));\n\n      const auto& S = (1 + evidence_occupied) + (1 + evidence_free);\n      m_occupied = evidence_occupied;\n      m_free = evidence_free;\n\n      // create occupancy color for visualization (m_occupied = red, m_free = green)\n      grid_map::colorVectorToValue(Eigen::Vector3f(m_occupied, m_free, 0), occupancy_color);\n    }\n  }\n  // TASK 5 END\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["There is a bug in the ",(0,c.jsx)(n.code,{children:"tensor_to_grid_map()"})," method. Make sure that the belief masses are computed correctly, then compile the ROS workspace and re-execute the launch file (after killing it with ",(0,c.jsx)(n.code,{children:"CTRL-C"}),")."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"catkin build pointcloud_ogm\nroslaunch pointcloud_ogm DeepISM.launch\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>t});var s=o(6540);const c={},i=s.createContext(c);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);